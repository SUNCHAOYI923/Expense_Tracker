# How to Use AI - Demo (All in English)

## 1. Setup

> 🎯 Goal: Let students run ChatGPT-generated Python code locally.

### Install VS Code

* Download: [https://code.visualstudio.com/](https://code.visualstudio.com/)
* Install the Python extension
* Open Terminal (Windows: Ctrl+`, Mac: Cmd+`)

### Install Python

* Download: [https://www.python.org/downloads/](https://www.python.org/downloads/)

* Make sure to check "Add Python to PATH"

* Verify installation:

  ```bash
  python --version
  ```

### Run Your First Python Program

1. Open VS Code, create a new file `hello.py`

2. Enter:

   ```python
   print("Hello, world!")
   ```

3. In terminal:

   ```bash
   python hello.py
   ```

4. You should see: `Hello, world!`

## 2. Project Overview

🛠️ This project demonstrates how to use **ChatGPT** to build and assemble code for a desktop "Expense Tracker" with:

- expense/income recording  
- budget reminders  
- report generation & export  
- data visualization  
- GUI  

You’ll learn:

- How to design effective prompts to generate backend logic  
  如何设计高效的 Prompt 来生成后端业务逻辑  
- How to interpret and test GPT outputs through a CLI  
  如何通过命令行测试并验证 GPT 输出的代码  
- How to integrate **pandas** and **matplotlib** for data analysis & visualization  
  如何使用 pandas 与 matplotlib 进行数据分析与可视化  
- How to connect Python backend with a **PyQt5** GUI  
  如何将 Python 后端逻辑与 PyQt5 图形界面结合  
- How to iterate and debug collaboratively with AI  
  如何与 AI 协作，快速迭代与调试代码  

## 3. Specific design

###  ① Frame Construction

A solid directory scaffold makes all future development smoother. The core job now is to ask the AI to turn that into a folder/file skeleton.  

But how to ask efficiently? 

**❌Bad Prompt**

> Generate a project directory structure for a smart expense tool with features: recording, reminders, reports, visualization, GUI.

Issues:

- No tech stack or language → AI might pick JavaScript, Java, etc.
- No concrete file/folder names → unpredictable output.
- No format specification → AI may return plain text, bullet list, or paragraph.

So we should identify prompt elements first.

1. **Context/Tech Stack** - Python, SQLite, pandas, matplotlib, etc.  
2. **Requirements** - List of files/folders that implement each feature  
3. **Output Format** - Markdown fenced code block, tree-view

##### ✅ Good Prompt

> I’m building a “Expense Tracker” app using Python, SQLite, pandas, matplotlib, ect.
> It needs to support:
>
>     1. expense/income recording
>     2. budget reminders
>     3. report generation & export
>     4. data visualization
>     5. GUI
>
> Please propose an initial project directory structure:
>
>   - Include clear Python file and folder names
>   - Provide a one-line description for each item
>   - Output it as a Markdown fenced code block in a tree-view format

**Outcome**

```markdown
expense_tracker/
├── main.py                    # App entry point (launches GUI)
├── database.py               # All database operations (models + queries)
├── config.py                 # Constants (DB path, budget limits, etc.)
│
├── core/                     # Core functionality
│   ├── tracker.py           # CRUD for income/expense records
│   ├── budget.py            # Budget calculations & alerts
│   └── reports.py           # Report/visualization generation
│
├── gui/                      # User interface
│   ├── main_window.py       # Main window layout (Tkinter/PyQt)
│   └── components.py        # Reusable UI widgets (tables, charts, etc.)
│
└── data/
    ├── expenses.db          # SQLite database file
    └── exports/             # Generated reports/charts
```

Build the project according to the framework and personalize it appropriately.

![1](https://github.com/SUNCHAOYI923/Expense_Tracker/blob/7d217a097ec3142c91b71f0d671bf4ee2ddc26a3/readme1.png)

### ② Code implementation

#### 1. Database

**Prompt**

> I’m building a “Smart Expense Tracker” desktop app in Python, and I want to use **pure pandas DataFrame** operations (no raw SQL) to create and manage my SQLite database. Please generate a Python module named `database.py`.
>
> Wrap your answer in a single `database.py` code block.

**Reference Code (Generated by AI)**

```python
import sqlite3
import pandas as pd
from pathlib import Path
from typing import Optional, Union

class ExpenseDatabase:
    def __init__(self, db_path: str = "resources/data.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()

    def _get_conn(self) -> sqlite3.Connection:
        return sqlite3.connect(self.db_path)

    def _init_db(self) -> None:
        with self._get_conn() as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS transactions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date TEXT NOT NULL,
                    amount REAL NOT NULL,
                    category TEXT NOT NULL,
                    description TEXT,
                    type TEXT CHECK(type IN ('income','expense'))
                )
            """)
            conn.execute("""
                CREATE TABLE IF NOT EXISTS budgets (
                    category TEXT PRIMARY KEY,
                    monthly_limit REAL NOT NULL
                )
            """)

    def add_transaction(self, data: Union[dict, pd.DataFrame]) -> None:
        if isinstance(data, dict):
            df = pd.DataFrame([data])
        elif isinstance(data, pd.Series):
            df = data.to_frame().T
        else:
            df = data.copy()
        for col in ("date","amount","category","description","type"):
            if col not in df.columns:
                df[col] = "" if col=="description" else None
        df = df[["date","amount","category","description","type"]]
        with self._get_conn() as conn:
            df.to_sql("transactions", conn, if_exists="append", index=False)

    def get_transactions(self,
                         start_date: Optional[str]=None,
                         end_date:   Optional[str]=None
                        ) -> pd.DataFrame:
        sql = "SELECT * FROM transactions"
        params = []
        if start_date or end_date:
            cond = []
            if start_date:
                cond.append("date>=?"); params.append(start_date)
            if end_date:
                cond.append("date<=?"); params.append(end_date)
            sql += " WHERE " + " AND ".join(cond)
        with self._get_conn() as conn:
            return pd.read_sql(sql, conn, params=params or None, parse_dates=["date"])

    def set_budget(self, category: str, limit: float) -> None:
        with self._get_conn() as conn:
            conn.execute("""
                INSERT INTO budgets(category, monthly_limit)
                VALUES(?,?)
                ON CONFLICT(category) DO UPDATE
                  SET monthly_limit = excluded.monthly_limit
            """, (category, limit))

    def get_budgets(self) -> pd.DataFrame:
        with self._get_conn() as conn:
            return pd.read_sql("SELECT category, monthly_limit FROM budgets", conn)

    def get_spending_summary(self) -> pd.DataFrame:
        with self._get_conn() as conn:
            spending = pd.read_sql(
                "SELECT category, SUM(amount) AS expense "
                "FROM transactions WHERE type='expense' GROUP BY category",
                conn
            )
            budgets = pd.read_sql("SELECT category, monthly_limit FROM budgets", conn)
        merged = pd.merge(budgets, spending, on="category", how="left").fillna(0)
        merged["remaining"] = merged["monthly_limit"] + merged["expense"]
        return merged[["category","expense","monthly_limit","remaining"]]

    def export_to_csv(self, filepath: str) -> None:
        df = self.get_transactions().drop(columns=["description"])  # drop empty column
        out = Path(filepath)
        out.parent.mkdir(parents=True, exist_ok=True)
        df.to_csv(out, index=False)
```

**Goal**

- Understand the contents of this table.
- Find the address where data is saved.

#### 2. core/tracker.py

**Prompt**

>  The database module (database.py) is done. Write `core/tracker.py` with these functions:
>
> 1. add_expense
> 2. add_income
> 3. remove_entry (Deletes the row from `transactions` table by id)
> 4. list_entries (Returns a DataFrame of the filtered rows)
>
> Constraints: 
>
>  • Import only from `database` and `pandas`
>
> • Use type hints and simple docstrings 
>
> • Keep each function under ~15 lines
>
> Format:  
>
> • Wrap your answer in a complete `core/tracker.py` code block 

**Reference Code**

```py
from typing import Optional
import pandas as pd
import sqlite3
from database import ExpenseDatabase

db = ExpenseDatabase()

def add_expense(date: str, amount: float, category: str, description: str) -> int:
    """Add an expense transaction and return its ID."""
    data = {
        "date": date,
        "amount": -abs(float(amount)),
        "category": category,
        "description": description,
        "type": "expense"
    }
    db.add_transaction(data)
    return _get_last_id()

def add_income(date: str, amount: float, category: str, description: str) -> int:
    """Add an income transaction and return its ID."""
    data = {
        "date": date,
        "amount": abs(float(amount)),
        "category": category,
        "description": description,
        "type": "income"
    }
    db.add_transaction(data)
    return _get_last_id()

def remove_transaction(tx_id: int) -> bool:
    """Remove a transaction by ID."""
    with sqlite3.connect(db.db_path) as conn:
        return conn.execute(
            "DELETE FROM transactions WHERE id = ?", (tx_id,)
        ).rowcount > 0

def get_transactions(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    category: Optional[str] = None
) -> pd.DataFrame:
    """Retrieve transactions with optional filters."""
    df = db.get_transactions(start_date, end_date)
    return df[df["category"] == category] if category else df

def _get_last_id() -> int:
    """Internal helper to get last inserted ID."""
    with sqlite3.connect(db.db_path) as conn:
        return conn.execute("SELECT last_insert_rowid()").fetchone()[0]
```

Now we need to make sure that the code works properly. Therefore, it is necessary now to make a prompt that asks ChatGPT to generate a comprehensive test script.

> I have two modules:     
>
> - database.py defines ExpenseDatabase     
> - core/tracker.py defines add_expense, add_income, list_entries, remove_entry
>
> Please generate a file named `test.py` that:
>
> - Create an ExpenseDatabase instance.      
> - Add two transactions (one expense, one income).   
> - Query all transactions.
> - Set budgets for [Catagory1] and [Catagory2]and print budgets.       
> - Print spending summary and alert.
> - Export all transactions to `data/transactions_export.csv` and print confirmation.

**Reference Code**

```py
from database import ExpenseDatabase
import pandas as pd
from pathlib import Path

def print_table(df: pd.DataFrame, title: str) -> None:
    print(f"\n=== {title} ===")
    if df.empty:
        print("No data")
    else:
        print(df.to_string(index=False))

def test_database() -> None:
    print("=== Expense Database Test ===")
    db = ExpenseDatabase()

    # 1. Add sample transactions
    print("\n1. Adding Transactions...")
    samples = [
        {"date":"2023-01-10","amount":-150.0,"category":"food","type":"expense"},
        {"date":"2023-01-15","amount":5000.0,"category":"salary","type":"income"},
        {"date":"2023-01-20","amount":-200.0,"category":"transport","type":"expense"}
    ]
    for t in samples:
        db.add_transaction(t)
    print_table(db.get_transactions(), "All Transactions")

    # 2. Set budgets
    print("\n2. Setting Budgets...")
    db.set_budget("food",500.0)
    db.set_budget("transport",300.0)
    print_table(db.get_budgets(), "Current Budgets")

    # 3. Spending summary
    print("\n3. Spending Summary:")
    summary = db.get_spending_summary()
    print_table(summary, "Detailed Summary")

    # 4. Export
    print("\n4. Exporting data...")
    export_path = "data/transactions.csv"
    db.export_to_csv(export_path)
    print(f"Data exported to {export_path}")

if __name__ == "__main__":
    # ensure data folder exists
    Path("data").mkdir(exist_ok=True)
    test_database()
    print("\nAll tests completed!")
```

**Goal**

- Able to understand and modify error reporting with AI.

  Hint1: You need to delete the original `data.db` if you modify `database.py`.

  Hint2: Missing some libraries can lead to compilation errors. (You May need use `pip` to install them.)

- Judge the correctness of the test.

  Hint: Judging whether the answer is correct by calculation.

- Ability to optimize code (e.g. reduce redundancy in fields)

  Hint: If you can't understand the modified code fragment well, you can try to ask AI to give the complete code.

The test reference is shown in the figure.

![2](https://github.com/SUNCHAOYI923/Expense_Tracker/blob/2b7f2eda1fc75abc5772eadc1a086f7391371f6b/readme2.png)

#### 3.core/budget.py & reports.py

Try to use your own words to prompt AI and test the codes. Here are reference codes.

```py
#core/budget.py
import sqlite3
import pandas as pd
from typing import Tuple
from database import ExpenseDatabase

db = ExpenseDatabase()

def set_category_budget(category: str, limit: float) -> None:
    """
    Set or update the monthly budget for a category.
    """
    db.set_budget(category, limit)

def get_category_budget(category: str) -> float:
    """
    Return the monthly_limit for the given category, or 0.0 if not defined.
    """
    budgets = db.get_budgets()
    row = budgets[budgets["category"] == category]
    return float(row["monthly_limit"].iloc[0]) if not row.empty else 0.0

def remove_category_budget(category: str) -> bool:
    """
    Remove a budget entry by category. Return True if deleted.
    """
    conn = sqlite3.connect(db.db_path)
    cur = conn.cursor()
    cur.execute("DELETE FROM budgets WHERE category = ?", (category,))
    conn.commit()
    deleted = cur.rowcount > 0
    conn.close()
    return deleted

def list_budgets() -> pd.DataFrame:
    """
    Return all budget entries as a DataFrame.
    """
    return db.get_budgets()

def check_budget(category: str) -> Tuple[bool, float]:
    """
    Check if a category is over its budget.
    Returns (is_over_budget, remaining_amount).
    """
    summary = db.get_spending_summary()
    row = summary[summary["category"] == category]
    if row.empty:
        return (False, 0.0)
    rem = float(row["remaining"].iloc[0])
    return (rem < 0, rem)

def budget_alerts(threshold: float = 0.0) -> pd.DataFrame:
    """
    Return categories whose remaining budget is <= threshold.
    """
    summary = db.get_spending_summary()
    return summary[summary["remaining"] <= threshold]
```

```py
#core/reports.py
import pandas as pd
from typing import Dict, Any
from database import ExpenseDatabase
from core.budget import get_category_budget

db = ExpenseDatabase()

def generate_monthly_report(month: str) -> Dict[str, float]:
    """
    Generate a report for a given month with total income, expense, and net.
    Month format: "YYYY-MM"
    """
    start_date = f"{month}-01";end_date = f"{month}-31"
    df = db.get_transactions(start_date=start_date, end_date=end_date)
    income = df[df["type"] == "income"]["amount"].sum()
    expense = df[df["type"] == "expense"]["amount"].sum()
    net = income + expense  # expense is negative
    return {"income": income, "expense": expense, "net": net}


def generate_category_report(month: str) -> pd.DataFrame:
    """
    Generate a category-wise report for a given month.
    Returns DataFrame with columns: category, income, expense, net
    """
    start_date = f"{month}-01";end_date = f"{month}-31"
    df = db.get_transactions(start_date=start_date, end_date=end_date)
    def pivot_and_format(category_type: str) -> pd.DataFrame:
        sub_df = df[df["type"] == category_type]
        return sub_df.groupby("category")["amount"].sum().reset_index().rename(
            columns={"amount": category_type}
        )
    income_df = pivot_and_format("income")
    expense_df = pivot_and_format("expense")
    merged = pd.merge(income_df, expense_df, on="category", how="outer").fillna(0)
    merged["net"] = merged["income"] + merged["expense"]
    return merged[["category", "income", "expense", "net"]]


def generate_budget_report(month: str) -> pd.DataFrame:
    """
    Generate a budget vs actual spending report.
    Returns DataFrame with columns: category, limit, spent, remaining
    """
    budget_df = db.get_budgets()
    if budget_df.empty:
        return pd.DataFrame(columns=["category", "limit", "spent", "remaining"])
    # Get spending for the month
    start_date = f"{month}-01";end_date = f"{month}-31"
    trans_df = db.get_transactions(start_date=start_date, end_date=end_date)
    spending = trans_df[trans_df["type"] == "expense"].groupby("category")["amount"].sum()
    spending.name = "spent"
    # Merge with budgets and fill missing spending as 0
    report = budget_df.set_index("category").join(spending).fillna(0)
    report["remaining"] = report["monthly_limit"] + report["spent"]  # expense is negative
    report = report.reset_index()
    report = report.rename(columns={"monthly_limit": "limit"})
    return report[["category", "limit", "spent", "remaining"]]


def get_monthly_trend(year: str) -> pd.DataFrame:
    """
    Get monthly income, expense, and net for a given year.
    Returns DataFrame with columns: month, income, expense, net
    """
    df = db.get_transactions()
    df["month"] = pd.to_datetime(df["date"]).dt.to_period("M").astype(str)
    trend = df.pivot_table(
        index="month",
        columns="type",
        values="amount",
        aggfunc="sum"
    ).fillna(0)
    trend["net"] = trend["income"] + trend["expense"]
    trend = trend.reset_index()
    trend = trend[trend["month"].str.startswith(year)]
    return trend[["month", "income", "expense", "net"]]
```

#### 4. Data Visualization  

Visualizing financial data is necessary in the project, we choose to use bar/pie/plot to analyze data.

**Prompt**

>  Please create a new file: `gui/vis.py` with functions to visualize financial data. Please include these functions:  
>
> 1. plot_monthly_summary(month: str)       - Bar chart showing income vs expense for the given month   
> 2. plot_category_spending(month: str)       - Pie chart showing spending distribution by category   
> 3. plot_budget_status(month: str)       - Horizontal bar chart showing budget vs actual spending   
> 4. plot_monthly_trend(year: str)       - Line chart showing income, expense, and net over months in a year

**Reference Code**

```py
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from core.reports import (
    generate_monthly_report,
    generate_category_report,
    generate_budget_report,
    get_monthly_trend
)

def plot_monthly_summary(month: str) -> None:
    """
    Bar chart showing income vs expense for a given month.
    """
    report = generate_monthly_report(month)
    data = {"Income": report["income"], "Expense": abs(report["expense"])}
    plt.figure(figsize=(6, 4))
    sns.barplot(x=list(data.keys()), y=list(data.values()), palette="viridis")
    plt.ylabel("Amount (USD)")
    plt.title(f"Monthly Summary - {month}")
    plt.tight_layout()
    plt.show()

def plot_category_spending(month: str) -> None:
    """
    Pie chart showing spending distribution by category.
    """
    df = generate_category_report(month)
    expense_df = df[df["expense"] < 0]
    if expense_df.empty:
        print("No expense data to plot.")
        return
    plt.figure(figsize=(7, 7))
    plt.pie(
        -expense_df["expense"], labels=expense_df["category"], autopct="%1.1f%%", startangle=140
    )
    plt.title(f"Spending Distribution - {month}")
    plt.axis("equal")
    plt.tight_layout()
    plt.show()

def plot_budget_status(month: str) -> None:
    """
    Horizontal bar chart comparing budget vs actual spending.
    """
    df = generate_budget_report(month)
    if df.empty:
        print("No budget data to plot.")
        return
    df["spent"] = -df["spent"]
    df = df.sort_values(by="spent", ascending=False)
    plt.figure(figsize=(8, 5))
    sns.barplot(x="spent", y="category", data=df, color="salmon", label="Spent")
    sns.barplot(x="limit", y="category", data=df, color="lightgreen", alpha=0.6, label="Budget")
    plt.xlabel("Amount (USD)")
    plt.ylabel("Category")
    plt.title(f"Budget vs Spending - {month}")
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_monthly_trend(year: str) -> None:
    """
    Line chart showing income, expense, and net over the months in the year.
    """
    df = get_monthly_trend(year)
    if df.empty:
        print("No trend data to plot.")
        return
    plt.figure(figsize=(10, 5))
    sns.lineplot(x="month", y="income", data=df, label="Income", marker="o")
    sns.lineplot(x="month", y="expense", data=df, label="Expense", marker="o")
    sns.lineplot(x="month", y="net", data=df, label="Net", marker="o")
    plt.xticks(rotation=45)
    plt.ylabel("Amount (USD)")
    plt.title(f"Monthly Financial Trend - {year}")
    plt.tight_layout()
    plt.legend()
    plt.show()
```

As the number of modules increases, testing becomes more complex. At this point, encapsulating tests effectively becomes even more crucial. You can test like this in the `test.py` : 

```py
if __name__ == "__main__":
    # Run all test modules respectively
    test_database_operations()
    test_budget_module()
    test_report_module()
    test_visualization()
```

#### 5. UI Design

The final step is to package this code into a complete desktop accounting tool with a UI design.

> Build a simple PyQt5 GUI that ties everything together and embeds Matplotlib charts.

#### 6. Debug &  Optimization

**Example**

>  Here’s the initial interface I got—it looks good, but testing revealed a few issues.
> ![3](https://github.com/SUNCHAOYI923/Expense_Tracker/blob/78e75e2d60ea363d577d36715c930b6748c0eb7f/readme3.png)
> ![4](https://github.com/SUNCHAOYI923/Expense_Tracker/blob/78e75e2d60ea363d577d36715c930b6748c0eb7f/readme4.png)
> - Adding a new category will cause an error. New category should be added in the database and the table should be refreshed immediately.
> - Adding empty field entries will cause an error.
> - Transaction date should not exceed the current date.
> - Click the button could cause errors.
> - Recommend implementing select-and-delete functionality for Budgets.
> - ......

Continuously improve in the process of interaction, so as to obtain the best version.

**Reference Code**

```py
#main.py
```

