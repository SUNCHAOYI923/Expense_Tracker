# How to Use AI - Demo (All in English)

## 1. Setup

> 🎯 Goal: Let students run ChatGPT-generated Python code locally.

### Install VS Code

* Download: [https://code.visualstudio.com/](https://code.visualstudio.com/)
* Install the Python extension
* Open Terminal (Windows: Ctrl+`, Mac: Cmd+`)

### Install Python

* Download: [https://www.python.org/downloads/](https://www.python.org/downloads/)

* Make sure to check "Add Python to PATH"

* Verify installation:

  ```bash
  python --version
  ```

### Run Your First Python Program

1. Open VS Code, create a new file `hello.py`

2. Enter:

   ```python
   print("Hello, world!")
   ```

3. In terminal:

   ```bash
   python hello.py
   ```

4. You should see: `Hello, world!`

## 2. Project Overview

🛠️ This project demonstrates how to use **ChatGPT** to build and assemble code for a desktop "Expense Tracker" with:

- expense/income recording  
- budget reminders  
- report generation & export  
- data visualization  
- GUI  

You’ll learn:

- How to design effective prompts to generate backend logic  
  如何设计高效的 Prompt 来生成后端业务逻辑  
- How to interpret and test GPT outputs through a CLI  
  如何通过命令行测试并验证 GPT 输出的代码  
- How to integrate **pandas** and **matplotlib** for data analysis & visualization  
  如何使用 pandas 与 matplotlib 进行数据分析与可视化  
- How to connect Python backend with a **PyQt5** GUI  
  如何将 Python 后端逻辑与 PyQt5 图形界面结合  
- How to iterate and debug collaboratively with AI  
  如何与 AI 协作，快速迭代与调试代码  

## 3. Specific design

#### ① Frame construction

A solid directory scaffold makes all future development smoother. The core job now is to ask the AI to turn that into a folder/file skeleton.  

But how to ask efficiently? 

**❌Bad Prompt**

> Generate a project directory structure for a smart expense tool with features: recording, reminders, reports, visualization, GUI.

Issues:

- No tech stack or language → AI might pick JavaScript, Java, etc.
- No concrete file/folder names → unpredictable output.
- No format specification → AI may return plain text, bullet list, or paragraph.

So we should identify prompt elements first.

1. **Context/Tech Stack** - Python, SQLite, pandas, matplotlib, etc.  
2. **Requirements** - List of files/folders that implement each feature  
3. **Output Format** - Markdown fenced code block, tree-view

##### ✅ Good Prompt

> I’m building a “Expense Tracker” app using Python, SQLite, pandas, matplotlib, ect.
> It needs to support:
>
>     1. expense/income recording
>     2. budget reminders
>     3. report generation & export
>     4. data visualization
>     5. GUI
>
> Please propose an initial project directory structure:
>
>   - Include clear Python file and folder names
>   - Provide a one-line description for each item
>   - Output it as a Markdown fenced code block in a tree-view format

**Outcome**

```markdown
expense_tracker/
├── main.py                    # App entry point (launches GUI)
├── database.py               # All database operations (models + queries)
├── config.py                 # Constants (DB path, budget limits, etc.)
│
├── core/                     # Core functionality
│   ├── tracker.py           # CRUD for income/expense records
│   ├── budget.py            # Budget calculations & alerts
│   └── reports.py           # Report/visualization generation
│
├── gui/                      # User interface
│   ├── main_window.py       # Main window layout (Tkinter/PyQt)
│   └── components.py        # Reusable UI widgets (tables, charts, etc.)
│
└── data/
    ├── expenses.db          # SQLite database file
    └── exports/             # Generated reports/charts
```

Build the project according to the framework and personalize it appropriately.

![1](https://github.com/SUNCHAOYI923/Expense_Tracker/blob/7d217a097ec3142c91b71f0d671bf4ee2ddc26a3/readme1.png)

### ② Code implementation

#### 1. Database

**Prompt**

> I’m building a “Smart Expense Tracker” desktop app in Python, and I want to use **pure pandas DataFrame** operations (no raw SQL) to create and manage my SQLite database. Please generate a Python module named `database.py`.
>
> Wrap your answer in a single `database.py` code block.

**Reference Code (Generated by AI)**

```python
import sqlite3
import pandas as pd
from pathlib import Path
from typing import Optional, Union

class ExpenseDatabase:
    def __init__(self, db_path: str = "resources/data.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()

    def _get_conn(self) -> sqlite3.Connection:
        return sqlite3.connect(self.db_path)

    def _init_db(self) -> None:
        with self._get_conn() as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS transactions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date TEXT NOT NULL,
                    amount REAL NOT NULL,
                    category TEXT NOT NULL,
                    description TEXT,
                    type TEXT CHECK(type IN ('income','expense'))
                )
            """)
            conn.execute("""
                CREATE TABLE IF NOT EXISTS budgets (
                    category TEXT PRIMARY KEY,
                    monthly_limit REAL NOT NULL
                )
            """)

    def add_transaction(self, data: Union[dict, pd.DataFrame]) -> None:
        if isinstance(data, dict):
            df = pd.DataFrame([data])
        elif isinstance(data, pd.Series):
            df = data.to_frame().T
        else:
            df = data.copy()
        for col in ("date","amount","category","description","type"):
            if col not in df.columns:
                df[col] = "" if col=="description" else None
        df = df[["date","amount","category","description","type"]]
        with self._get_conn() as conn:
            df.to_sql("transactions", conn, if_exists="append", index=False)

    def get_transactions(self,
                         start_date: Optional[str]=None,
                         end_date:   Optional[str]=None
                        ) -> pd.DataFrame:
        sql = "SELECT * FROM transactions"
        params = []
        if start_date or end_date:
            cond = []
            if start_date:
                cond.append("date>=?"); params.append(start_date)
            if end_date:
                cond.append("date<=?"); params.append(end_date)
            sql += " WHERE " + " AND ".join(cond)
        with self._get_conn() as conn:
            return pd.read_sql(sql, conn, params=params or None, parse_dates=["date"])

    def set_budget(self, category: str, limit: float) -> None:
        with self._get_conn() as conn:
            conn.execute("""
                INSERT INTO budgets(category, monthly_limit)
                VALUES(?,?)
                ON CONFLICT(category) DO UPDATE
                  SET monthly_limit = excluded.monthly_limit
            """, (category, limit))

    def get_budgets(self) -> pd.DataFrame:
        with self._get_conn() as conn:
            return pd.read_sql("SELECT category, monthly_limit FROM budgets", conn)

    def get_spending_summary(self) -> pd.DataFrame:
        with self._get_conn() as conn:
            spending = pd.read_sql(
                "SELECT category, SUM(amount) AS expense "
                "FROM transactions WHERE type='expense' GROUP BY category",
                conn
            )
            budgets = pd.read_sql("SELECT category, monthly_limit FROM budgets", conn)
        merged = pd.merge(budgets, spending, on="category", how="left").fillna(0)
        merged["remaining"] = merged["monthly_limit"] + merged["expense"]
        return merged[["category","expense","monthly_limit","remaining"]]

    def export_to_csv(self, filepath: str) -> None:
        df = self.get_transactions().drop(columns=["description"])  # drop empty column
        out = Path(filepath)
        out.parent.mkdir(parents=True, exist_ok=True)
        df.to_csv(out, index=False)
```

**Goal**

- Understand the contents of this table.
- Find the address where data is saved.

#### 2. Database

**Prompt**

>  The database module (database.py) is done. Write `core/tracker.py` with these functions:
>
> 1. add_expense
> 2. add_income
> 3. remove_entry (Deletes the row from `transactions` table by id)
> 4. list_entries (Returns a DataFrame of the filtered rows)
>
> Constraints: 
>
>  • Import only from `database` and `pandas`
>
> • Use type hints and simple docstrings 
>
> • Keep each function under ~15 lines
>
> Format:  
>
> • Wrap your answer in a complete `core/tracker.py` code block 

**Reference Code**

```py
from typing import Optional
import pandas as pd
import sqlite3
from database import ExpenseDatabase

db = ExpenseDatabase()

def add_expense(date: str, amount: float, category: str, description: str) -> int:
    """Add an expense transaction and return its ID."""
    data = {
        "date": date,
        "amount": -abs(float(amount)),
        "category": category,
        "description": description,
        "type": "expense"
    }
    db.add_transaction(data)
    return _get_last_id()

def add_income(date: str, amount: float, category: str, description: str) -> int:
    """Add an income transaction and return its ID."""
    data = {
        "date": date,
        "amount": abs(float(amount)),
        "category": category,
        "description": description,
        "type": "income"
    }
    db.add_transaction(data)
    return _get_last_id()

def remove_transaction(tx_id: int) -> bool:
    """Remove a transaction by ID."""
    with sqlite3.connect(db.db_path) as conn:
        return conn.execute(
            "DELETE FROM transactions WHERE id = ?", (tx_id,)
        ).rowcount > 0

def get_transactions(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    category: Optional[str] = None
) -> pd.DataFrame:
    """Retrieve transactions with optional filters."""
    df = db.get_transactions(start_date, end_date)
    return df[df["category"] == category] if category else df

def _get_last_id() -> int:
    """Internal helper to get last inserted ID."""
    with sqlite3.connect(db.db_path) as conn:
        return conn.execute("SELECT last_insert_rowid()").fetchone()[0]
```

Now we need to make sure that the code works properly. Therefore, it is necessary now to make a prompt that asks ChatGPT to generate a comprehensive test script.

> I have two modules:     
>
> - database.py defines ExpenseDatabase     
> - core/tracker.py defines add_expense, add_income, list_entries, remove_entry
>
> Please generate a file named `main.py` that:
>
> - Create an ExpenseDatabase instance.      
> - Add two transactions (one expense, one income).   
> - Query all transactions.
> - Set budgets for [Catagory1] and [Catagory2]and print budgets.       
> - Print spending summary and alert.
> - Export all transactions to `data/transactions_export.csv` and print confirmation.

**Reference Code**

```py
from database import ExpenseDatabase
import pandas as pd
from pathlib import Path

def print_table(df: pd.DataFrame, title: str) -> None:
    print(f"\n=== {title} ===")
    if df.empty:
        print("No data")
    else:
        print(df.to_string(index=False))

def test_database() -> None:
    print("=== Expense Database Test ===")
    db = ExpenseDatabase()

    # 1. Add sample transactions
    print("\n1. Adding Transactions...")
    samples = [
        {"date":"2023-01-10","amount":-150.0,"category":"food","type":"expense"},
        {"date":"2023-01-15","amount":5000.0,"category":"salary","type":"income"},
        {"date":"2023-01-20","amount":-200.0,"category":"transport","type":"expense"}
    ]
    for t in samples:
        db.add_transaction(t)
    print_table(db.get_transactions(), "All Transactions")

    # 2. Set budgets
    print("\n2. Setting Budgets...")
    db.set_budget("food",500.0)
    db.set_budget("transport",300.0)
    print_table(db.get_budgets(), "Current Budgets")

    # 3. Spending summary
    print("\n3. Spending Summary:")
    summary = db.get_spending_summary()
    print_table(summary, "Detailed Summary")

    # 4. Export
    print("\n4. Exporting data...")
    export_path = "data/transactions.csv"
    db.export_to_csv(export_path)
    print(f"Data exported to {export_path}")

if __name__ == "__main__":
    # ensure data folder exists
    Path("data").mkdir(exist_ok=True)
    test_database()
    print("\nAll tests completed!")
```

**Goal**

- Able to understand and modify error reporting with AI.

  Hint1: You need to delete the original `data.db` if you modify `database.py`.

  Hint2: Missing some libraries can lead to compilation errors. (You May need use `pip` to install them.)

- Judge the correctness of the test.

  Hint: Judging whether the answer is correct by calculation.

- Ability to optimize code (e.g. reduce redundancy in fields)

  Hint: If you can't understand the modified code fragment well, you can try to ask AI to give the complete code.

The test reference is shown in the figure.

![2](https://github.com/SUNCHAOYI923/Expense_Tracker/blob/2b7f2eda1fc75abc5772eadc1a086f7391371f6b/readme2.png)